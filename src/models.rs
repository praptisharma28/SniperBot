// src/models.rs


// Token = Basic info card (name, address, where we found it)
// TokenMetrics = Report card (price, volume, how risky it is)
// TradingSignal = Alert message ("BUY THIS!" or "DANGER!")
// SimulatedTrade = Practice trade record (did we make money?)


use chrono::{DateTime, Utc};
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use sqlx::FromRow;

/// Represents a cryptocurrency token we're tracking
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct Token {
    pub id: Option<i64>,
    pub address: String,           // Contract address
    pub symbol: String,           // e.g., "PEPE"
    pub name: String,             // e.g., "Pepe Coin"
    pub chain: String,            // e.g., "solana", "ethereum"
    pub source: String,           // Where we found it: "dex_screener", "pump_fun", etc.
    pub created_at: DateTime<Utc>,
    pub first_seen: DateTime<Utc>,
    pub is_active: bool,
}

/// Market data for a token at a specific point in time
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct TokenMetrics {
    pub id: Option<i64>,
    pub token_address: String,
    pub timestamp: DateTime<Utc>,
    
    // Price data
    pub price_usd: Option<Decimal>,
    pub market_cap_usd: Option<Decimal>,
    pub liquidity_usd: Option<Decimal>,
    pub volume_24h_usd: Option<Decimal>,
    
    // Supply data
    pub total_supply: Option<Decimal>,
    pub circulating_supply: Option<Decimal>,
    
    // Holder data
    pub holder_count: Option<u32>,
    pub top_10_holders_percentage: Option<Decimal>,
    
    // Risk indicators
    pub is_honeypot: Option<bool>,
    pub is_mintable: Option<bool>,
    pub has_proxy: Option<bool>,
    pub contract_verified: Option<bool>,
}

/// A trading signal generated by our analysis
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct TradingSignal {
    pub id: Option<i64>,
    pub token_address: String,
    pub signal_type: SignalType,
    pub confidence: Decimal,        // 0.0 to 1.0
    pub reason: String,             // Why we generated this signal
    pub target_multiplier: Option<Decimal>, // Expected profit (2x, 5x, etc.)
    pub created_at: DateTime<Utc>,
    pub is_sent: bool,              // Have we sent this to Telegram?
}

#[derive(Debug, Clone, Serialize, Deserialize, sqlx::Type)]
#[sqlx(type_name = "signal_type", rename_all = "lowercase")]
pub enum SignalType {
    Buy,
    Sell,
    Warning,    // Potential rug pull detected
    WhaleMovement,
}

/// Simulated trade for backtesting
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct SimulatedTrade {
    pub id: Option<i64>,
    pub token_address: String,
    pub entry_price: Decimal,
    pub entry_time: DateTime<Utc>,
    pub exit_price: Option<Decimal>,
    pub exit_time: Option<DateTime<Utc>>,
    pub investment_usd: Decimal,
    pub profit_loss: Option<Decimal>,
    pub multiplier: Option<Decimal>,
    pub exit_reason: Option<String>, // "target_reached", "stop_loss", "time_limit"
    pub is_active: bool,
}

/// Whale wallet we're tracking
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct WhaleWallet {
    pub id: Option<i64>,
    pub address: String,
    pub chain: String,
    pub label: Option<String>,      // e.g., "Smart Money Wallet #1"
    pub balance_usd: Option<Decimal>,
    pub success_rate: Option<Decimal>, // Historical success rate
    pub avg_multiplier: Option<Decimal>, // Average profit multiplier
    pub is_active: bool,
    pub created_at: DateTime<Utc>,
}

/// A transaction made by a whale wallet
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct WhaleTransaction {
    pub id: Option<i64>,
    pub whale_address: String,
    pub token_address: String,
    pub transaction_hash: String,
    pub action: TransactionAction,
    pub amount_tokens: Decimal,
    pub amount_usd: Option<Decimal>,
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize, sqlx::Type)]
#[sqlx(type_name = "transaction_action", rename_all = "lowercase")]
pub enum TransactionAction {
    Buy,
    Sell,
    Transfer,
}

/// Configuration for our analysis rules
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnalysisRules {
    pub min_liquidity: Decimal,
    pub max_top_holder_pct: Decimal,
    pub min_holders: u32,
    pub honeypot_check: bool,
    pub contract_verification_required: bool,
}

/// Result of analyzing a token
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnalysisResult {
    pub token_address: String,
    pub score: Decimal,             // 0.0 to 1.0 overall score
    pub is_safe: bool,
    pub risk_level: RiskLevel,
    pub flags: Vec<String>,         // List of warning flags
    pub potential_multiplier: Option<Decimal>,
    pub recommendation: Recommendation,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RiskLevel {
    Low,
    Medium,
    High,
    Extreme,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Recommendation {
    Buy,
    Watch,
    Avoid,
}
